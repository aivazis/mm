# bash completion for mm build system                      -*- shell-script -*-

# =============================================================================
# Global targets
# =============================================================================

# All targets that are always available regardless of project configuration.
# Extracted from make/mm/rules.mm, make/builder/rules.mm, make/platforms/rules.mm,
# make/hosts/rules.mm, make/users/rules.mm, make/developers/rules.mm,
# make/compilers/rules.mm, make/languages/rules.mm, make/targets/rules.mm,
# make/extern/rules.mm, make/projects/model.mm, make/projects/rules.mm,
# make/libraries/rules.mm, make/packages/rules.mm, make/extensions/rules.mm,
# make/tests/rules.mm, make/docker-images/rules.mm, make/webpack/rules.mm,
# make/vite/rules.mm
_comp_cmd_mm__global_targets="
help
mm.usage
mm.banner
mm.config
mm.info
make.info
builder.info
builder.info.help
builder.info.tmp
builder.info.prefix
builder.info.bin
builder.info.doc
builder.info.inc
builder.info.lib
builder.info.share
builder.info.pyc
builder.info.staging
platform.info
host.info
user.info
developer.info
compilers.info
languages.info
suffixes.info
targets.info
extern.info
extern.db.clean
projects
projects.boot
projects.shutdown
projects.info
tests
tests.clean
clean
tidy
libraries.info
packages.info
extensions.info
tests.info
docker-images.info
webpack.info
vite.info
"

# =============================================================================
# Per-asset target suffix tables
# =============================================================================

# Per-project suffixes (from make/projects/rules.mm)
# The bare name is always added separately
_comp_cmd_mm__project_suffixes="
.directories
.assets
.clean
.info
.info.contents
.help
"

# Per-library suffixes (from make/libraries/rules.mm)
_comp_cmd_mm__library_suffixes="
.clean
.prerequisites
.directories
.assets
.headers.gateway
.headers
.autogen.cleanup
.cleangen
.archive
.dll
.info
.info.directories
.info.sources
.info.sources.cuda
.info.headers
.info.objects
.info.objects.cuda
.info.incdirs
.info.api
.info.languages
.help
"

# Per-package suffixes (from make/packages/rules.mm)
_comp_cmd_mm__package_suffixes="
.clean
.directories
.assets
.pyc
.drivers
.config
.meta
.meta.source
.info
.info.directories
.info.sources
.info.pyc
.info.pycdirs
.info.config
.info.general
.info.package
.info.meta
.help
"

# Per-extension suffixes (from make/extensions/rules.mm)
_comp_cmd_mm__extension_suffixes="
.prerequisites
.directories
.assets
.extension
.clean
.headers
.archive
.capsule
.module.init
.module.init.clean
.info
"

# Per-test-suite suffixes (from make/tests/rules.mm)
_comp_cmd_mm__testsuite_suffixes="
.testcases
.clean
.info
.help
.info.directories
.info.drivers
.info.languages
.info.staging.targets
"

# Per-docker-image suffixes (from make/docker-images/rules.mm)
_comp_cmd_mm__docker_suffixes="
.clean
.build
.run
.launch
.info
.help
"

# Per-webpack suffixes (from make/webpack/rules.mm)
_comp_cmd_mm__webpack_suffixes="
.clean
.generated
.chunks
.generate.prep
.static
.config
.sources
.npm_modules
.info
.info.sources
.info.staged
.info.installed
.info.page
.info.root
.info.config
.info.client
.info.schema
.info.staging
.info.prefix
.help
"

# Per-vite bundle suffixes (from make/vite/rules.mm)
_comp_cmd_mm__vite_suffixes="
.config
.stage.config
.stage.dirs
.stage.files
.stage.modules
.directories
.staging.prefix
.info
.info.config
.help
"

# Per-verbatim suffixes (from make/verbatim/rules.mm)
_comp_cmd_mm__verbatim_suffixes="
.clean
.info
.info.files
.info.staged.files
.info.directories
.info.staged.directories
.help
"

# =============================================================================
# Target descriptions (for inline help via F2 / configurable key)
# =============================================================================

# Get a short description for a target
# @param target  The target name
# @return Description string, or empty if unknown
_comp_cmd_mm__get_target_description()
{
    local target=$1

    case "$target" in
        # --- Core mm system ---
        help|mm.usage)       echo "Show usage information" ;;
        mm.banner)           echo "Print the mm version banner" ;;
        mm.config)           echo "Show makefile search path" ;;
        mm.info)             echo "Show important mm variables" ;;
        make.info)           echo "Show GNU Make variables" ;;

        # --- Builder layout ---
        builder.info)        echo "Show builder directory layout" ;;
        builder.info.help)   echo "List targets that print build layout" ;;
        builder.info.tmp)    echo "Show staging directory" ;;
        builder.info.prefix) echo "Show install prefix" ;;
        builder.info.bin)    echo "Show bin directory" ;;
        builder.info.doc)    echo "Show doc directory" ;;
        builder.info.inc)    echo "Show include directory" ;;
        builder.info.lib)    echo "Show lib directory" ;;
        builder.info.share)  echo "Show share directory" ;;
        builder.info.pyc)    echo "Show Python bytecode directory" ;;
        builder.info.staging) echo "Show staging directory" ;;

        # --- Platform / host / user ---
        platform.info)       echo "Show platform information (os, arch)" ;;
        host.info)           echo "Show host information (name, cores)" ;;
        user.info)           echo "Show user information (name, email)" ;;
        developer.info)      echo "Show developer options/overrides" ;;

        # --- Compilers / languages ---
        compilers.info)      echo "Show language-to-compiler map" ;;
        languages.info)      echo "List known languages" ;;
        suffixes.info)       echo "Show file extension to language map" ;;
        targets.info)        echo "Show target tag and variants" ;;

        # --- External packages ---
        extern.info)         echo "Show external package support" ;;
        extern.db.clean)     echo "Remove package database file" ;;
        extern.*.info)       echo "Show info for external package" ;;

        # --- Project orchestration ---
        projects)            echo "Build all projects" ;;
        projects.boot)       echo "Log build start and setup" ;;
        projects.shutdown)   echo "Log build finish" ;;
        projects.info)       echo "List known projects" ;;
        tests)               echo "Run all test suites" ;;
        tests.clean)         echo "Clean all test suites" ;;
        clean)               echo "Clean all projects and tests" ;;
        tidy)                echo "Delete *~ backup files" ;;

        # --- Asset category listings ---
        libraries.info)      echo "List known libraries" ;;
        packages.info)       echo "List known packages" ;;
        extensions.info)     echo "List known extensions" ;;
        tests.info)          echo "List known test suites" ;;
        docker-images.info)  echo "List known docker images" ;;
        webpack.info)        echo "List known webpack bundles" ;;
        vite.info)           echo "List known vite bundles" ;;

        # --- Per-asset suffix descriptions ---
        *.directories)       echo "Create required directories" ;;
        *.assets)            echo "Build all assets" ;;
        *.clean)             echo "Clean artifacts" ;;
        *.info)              echo "Show metadata" ;;
        *.info.contents)     echo "Show asset contents" ;;
        *.help)              echo "Show documentation" ;;
        *.prerequisites)     echo "Build prerequisites" ;;
        *.headers.gateway)   echo "Publish gateway headers" ;;
        *.headers)           echo "Publish exported headers" ;;
        *.autogen.cleanup)   echo "Clean up autogenerated files" ;;
        *.cleangen)          echo "Remove autogenerated files" ;;
        *.archive)           echo "Build static archive (.a)" ;;
        *.dll)               echo "Build shared library (.so/.dylib)" ;;
        *.info.directories)  echo "Show directory layout" ;;
        *.info.sources)      echo "Show source files" ;;
        *.info.sources.cuda) echo "Show CUDA source files" ;;
        *.info.headers)      echo "Show header files" ;;
        *.info.objects)      echo "Show object files" ;;
        *.info.objects.cuda) echo "Show CUDA object files" ;;
        *.info.incdirs)      echo "Show include directories" ;;
        *.info.api)          echo "Show exported public headers" ;;
        *.info.languages)    echo "Show source languages and flags" ;;
        *.pyc)               echo "Byte-compile Python sources" ;;
        *.drivers)           echo "Export driver scripts" ;;
        *.config)            echo "Export configuration files" ;;
        *.meta)              echo "Build package metadata" ;;
        *.meta.source)       echo "Generate metadata .py source" ;;
        *.info.pyc)          echo "Show byte-compiled files" ;;
        *.info.pycdirs)      echo "Show byte-compile directories" ;;
        *.info.config)       echo "Show configuration files" ;;
        *.info.general)      echo "Show general metadata" ;;
        *.info.package)      echo "Show package install path" ;;
        *.info.meta)         echo "Show package metadata paths" ;;
        *.extension)         echo "Build the .so module" ;;
        *.capsule)           echo "Publish capsule headers" ;;
        *.module.init)       echo "Build module init from main" ;;
        *.module.init.clean) echo "Remove generated init file" ;;
        *.testcases)         echo "Build all test cases" ;;
        *.info.drivers)      echo "Show test case drivers" ;;
        *.info.staging.targets) echo "Show test make targets" ;;
        *.build)             echo "Run docker build" ;;
        *.run)               echo "Run docker container" ;;
        *.launch)            echo "Run docker interactively" ;;
        *.generated)         echo "Build relay-generated bundle" ;;
        *.chunks)            echo "Build external dependency chunks" ;;
        *.generate.prep)     echo "Prepare for generation" ;;
        *.static)            echo "Build static assets" ;;
        *.sources)           echo "Stage source files" ;;
        *.npm_modules)       echo "Install npm dependencies" ;;
        *.info.staged)       echo "List staged files" ;;
        *.info.installed)    echo "List installed files" ;;
        *.info.page)         echo "Show page paths" ;;
        *.info.root)         echo "Show pack prefix" ;;
        *.info.client)       echo "Show client path" ;;
        *.info.schema)       echo "Show schema path" ;;
        *.info.staging)      echo "Show staging prefix" ;;
        *.info.prefix)       echo "Show install prefix" ;;
        *.stage.config)      echo "Stage configuration files" ;;
        *.stage.dirs)        echo "Create staging directories" ;;
        *.stage.files)       echo "Stage source files" ;;
        *.stage.modules)     echo "Install/update node modules" ;;
        *.staging.prefix)    echo "Create staging area" ;;
        *.info.files)        echo "List source files" ;;
        *.info.staged.files) echo "List staged files" ;;
        *.info.staged.directories) echo "List staged directories" ;;

        # --- Per-test-case ---
        *.pre)               echo "Test startup dependencies" ;;
        *.post)              echo "Test cleanup" ;;
        *.cases)             echo "Run test cases" ;;
        *.driver)            echo "Compile test executable" ;;

        *)                   echo "" ;;
    esac
}

# =============================================================================
# Show target help (bound to F2 or MM_HELP_KEY)
# =============================================================================

# Show help for the target currently being typed
# This function is bound to a key (default: F2) and displays
# a description of the current word on the command line
_comp_cmd_mm__show_target_help()
{
    local current_word="${READLINE_LINE##* }"
    [[ -z "$current_word" ]] && return

    local desc
    desc=$(_comp_cmd_mm__get_target_description "$current_word")

    if [[ -n "$desc" ]]; then
        # Print on a new line without disturbing the command line
        echo ""
        echo "  $current_word -- $desc"
        # Redraw the prompt
        local prompt_cmd
        prompt_cmd=$(PROMPT_COMMAND= PS1="$PS1" bash -ic 'echo "$PS1"' 2>/dev/null)
        echo -n "$prompt_cmd$READLINE_LINE"
    fi
}

# Standalone command for target help lookup
mm-target-help()
{
    local target="${1:-}"
    if [[ -z "$target" ]]; then
        echo "Usage: mm-target-help <target>"
        echo ""
        echo "Global targets:"
        local t
        for t in $_comp_cmd_mm__global_targets; do
            local desc
            desc=$(_comp_cmd_mm__get_target_description "$t")
            [[ -n "$desc" ]] && printf "  %-30s %s\n" "$t" "$desc"
        done
        return
    fi

    local desc
    desc=$(_comp_cmd_mm__get_target_description "$target")
    if [[ -n "$desc" ]]; then
        echo "$target -- $desc"
    else
        echo "No description available for '$target'"
    fi
}

# =============================================================================
# Project configuration parsing
# =============================================================================

# Find the project root by walking up from CWD looking for .mm/
# @return Path to project root, or empty string
_comp_cmd_mm__find_project_root()
{
    local dir="$PWD"
    while [[ "$dir" != "/" && "$dir" != "" ]]; do
        if [[ -d "$dir/.mm" ]]; then
            echo "$dir"
            return
        fi
        dir=$(dirname "$dir")
    done
}

# Find the mm installation directory by locating the make/ tree
# Searches: relative to the mm command, MM_HOME, common paths
# @return Path to mm installation (containing make/), or empty
_comp_cmd_mm__find_mm_home()
{
    # Try MM_HOME environment variable first
    if [[ -n "${MM_HOME:-}" && -d "$MM_HOME/make" ]]; then
        echo "$MM_HOME"
        return
    fi

    # Try to resolve from the mm command location
    local mm_path
    mm_path=$(command -v mm 2>/dev/null)
    if [[ -n "$mm_path" ]]; then
        # Resolve symlinks
        local resolved
        resolved=$(readlink -f "$mm_path" 2>/dev/null || echo "$mm_path")
        local mm_dir
        mm_dir=$(dirname "$resolved")

        # mm is typically at the root of the mm repo
        if [[ -d "$mm_dir/make" ]]; then
            echo "$mm_dir"
            return
        fi
        # Or in a bin/ subdirectory
        local parent
        parent=$(dirname "$mm_dir")
        if [[ -d "$parent/make" ]]; then
            echo "$parent"
            return
        fi
    fi

    # Try DV_DIR/mm (common user setup)
    if [[ -n "${DV_DIR:-}" && -d "$DV_DIR/mm/make" ]]; then
        echo "$DV_DIR/mm"
        return
    fi
}

# Parse all asset declarations from .mm config files
# Extracts: libraries, packages, extensions, tests, docker-images,
#           webpack, vite, verbatim
# @param project_root  Path to the project root directory
# @return Lines in format: "type|name" (e.g., "library|hello.lib")
_comp_cmd_mm__parse_assets()
{
    local project_root=$1
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    for config_file in "$mm_dir"/*.mm; do
        [[ ! -f "$config_file" ]] && continue

        # Extract asset declarations using awk
        # Patterns:
        #   project.libraries := lib1 lib2
        #   project.packages := pkg1 pkg2
        #   project.extensions := ext1
        #   project.tests := tst1 tst2
        #   project.docker-images := img1
        #   project.webpack := wp1
        #   project.vite := vite1
        #   project.verbatim := v1
        awk '
        /\.libraries[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "library|" a[i];
            # Handle continuation lines
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "library|" a[i];
            }
        }
        /\.packages[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "package|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "package|" a[i];
            }
        }
        /\.extensions[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "extension|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "extension|" a[i];
            }
        }
        /\.tests[[:space:]]*:?=[[:space:]]/ {
            # Skip lines like .tests.foo.stem (those are sub-properties)
            if ($0 ~ /\.tests\.[^[:space:]]+\./) next;
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "testsuite|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "testsuite|" a[i];
            }
        }
        /\.docker-images[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "docker|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "docker|" a[i];
            }
        }
        /\.webpack[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "webpack|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "webpack|" a[i];
            }
        }
        /\.vite[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "vite|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "vite|" a[i];
            }
        }
        /\.verbatim[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "verbatim|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "verbatim|" a[i];
            }
        }
        ' "$config_file"
    done | sort -u
}

# Get the project names from .mm/ directory
# @param project_root  Path to the project root directory
# @return List of project names (one per line)
_comp_cmd_mm__get_project_names()
{
    local project_root=$1
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    for mmfile in "$mm_dir"/*.mm; do
        [[ ! -f "$mmfile" ]] && continue
        basename "$mmfile" .mm
    done
}

# =============================================================================
# Test target discovery (filesystem scan)
# =============================================================================

# Parse test suite configuration from .mm configuration files
# Returns both stem and root for each test suite
# @param project_root  Path to the project root directory
# @return Lines in format: "stem|root" (e.g., "serial|TEST/serial/")
_comp_cmd_mm__parse_test_suites()
{
    local project_root=$1
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    local -A suite_stems
    local -A suite_roots

    # Parse all .mm and .tests files
    for config_file in "$mm_dir"/*.mm "$mm_dir"/*.tests; do
        [[ ! -f "$config_file" ]] && continue

        # Extract stem definitions
        # Example: summit.tst.serial.stem := serial
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            if [[ "$line" =~ \.tst\.([^.]+)\.stem[[:space:]]*:=[[:space:]]*([^[:space:]#]+) ]]; then
                local suite="${BASH_REMATCH[1]}"
                local stem="${BASH_REMATCH[2]}"
                suite_stems["$suite"]="$stem"
            elif [[ "$line" =~ \.tests\.([^.]+)\.stem[[:space:]]*:=[[:space:]]*([^[:space:]#]+) ]]; then
                local suite="${BASH_REMATCH[1]}"
                local stem="${BASH_REMATCH[2]}"
                suite_stems["$suite"]="$stem"
            fi
        done < <(grep -E '\.tst\.[^.]+\.stem\s*:=|\.tests\.[^.]+\.stem\s*:=' "$config_file" 2>/dev/null)

        # Extract root definitions
        # Example: summit.tst.serial.root := TEST/serial/
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            if [[ "$line" =~ \.tst\.([^.]+)\.root[[:space:]]*:=[[:space:]]*([^[:space:]#]+) ]]; then
                local suite="${BASH_REMATCH[1]}"
                local root="${BASH_REMATCH[2]}"
                suite_roots["$suite"]="$root"
            elif [[ "$line" =~ \.tests\.([^.]+)\.root[[:space:]]*:=[[:space:]]*([^[:space:]#]+) ]]; then
                local suite="${BASH_REMATCH[1]}"
                local root="${BASH_REMATCH[2]}"
                suite_roots["$suite"]="$root"
            fi
        done < <(grep -E '\.tst\.[^.]+\.root\s*:=|\.tests\.[^.]+\.root\s*:=' "$config_file" 2>/dev/null)
    done

    # Output suite info: stem|root
    for suite in "${!suite_stems[@]}"; do
        local stem="${suite_stems[$suite]}"
        local root="${suite_roots[$suite]:-tests/$stem/}"  # Default if not specified
        echo "$stem|$root"
    done
}

# Parse test exclusion patterns from .mm configuration files
# @param project_root  Path to the project root directory
# @param stem         Test suite stem to get exclusions for
# @return List of exclusion patterns (relative paths)
_comp_cmd_mm__get_exclusions()
{
    local project_root=$1
    local stem=$2
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    local exclusions=""

    for config_file in "$mm_dir"/*.mm "$mm_dir"/*.tests; do
        [[ ! -f "$config_file" ]] && continue

        # Use awk to handle multi-line exclusions with backslash continuation
        exclusions="$exclusions$(awk -v stem="$stem" '
            /\.tst\.[^.]+\.drivers\.exclude|\.tests\.[^.]+\.drivers\.exclude/ {
                if ($0 ~ ("\\." stem "\\.drivers\\.exclude")) {
                    # Remove everything up to += or :=
                    sub(/^[^+:]*[+:]=[[:space:]]*/, "");
                    line = $0;

                    # Handle backslash continuation
                    while (line ~ /\\[[:space:]]*$/) {
                        sub(/\\[[:space:]]*$/, "", line);
                        print line;
                        if (getline > 0) {
                            sub(/^[[:space:]]*/, "", $0);
                            line = $0;
                        } else {
                            break;
                        }
                    }
                    print line;
                }
            }
        ' "$config_file" 2>/dev/null | tr '\n' ' ')"
    done

    # Split into individual patterns and clean up
    echo "$exclusions" | tr ' ' '\n' | grep -v '^$' | sed 's/[[:space:]]*$//'
}

# Check if a test file matches any exclusion pattern
# @param test_file    Relative path of test file (from tests/stem/)
# @param exclusions   Space-separated list of exclusion patterns
# @return 0 if excluded, 1 if not excluded
_comp_cmd_mm__is_excluded()
{
    local test_file=$1
    shift
    local exclusions=("$@")

    for pattern in "${exclusions[@]}"; do
        [[ -z "$pattern" ]] && continue

        local clean_pattern="${pattern#*/}"  # Remove leading directory if present

        if [[ "$test_file" == $clean_pattern || "$test_file" == *"/$clean_pattern" ]]; then
            return 0  # Excluded
        fi
    done

    return 1  # Not excluded
}

# Generate test targets by scanning the test directories
# @param project_root  Path to the project root directory
# @return List of test targets (tests.stem.name format)
_comp_cmd_mm__get_test_targets()
{
    local project_root=$1

    local suites
    suites=$(_comp_cmd_mm__parse_test_suites "$project_root")

    [[ -z "$suites" ]] && return

    local targets=""

    while IFS='|' read -r stem root; do
        [[ -z "$stem" || -z "$root" ]] && continue

        local test_dir="$project_root/$root"
        test_dir="${test_dir%/}"

        [[ ! -d "$test_dir" ]] && continue

        # Get exclusions for this stem
        local exclusions
        IFS=$'\n' read -r -d '' -a exclusions < <(_comp_cmd_mm__get_exclusions "$project_root" "$stem" && printf '\0')

        # Find all test files (C++, Python, Fortran, C)
        while IFS= read -r -d '' test_file; do
            local rel_path="${test_file#$test_dir/}"

            if _comp_cmd_mm__is_excluded "$rel_path" "${exclusions[@]}"; then
                continue
            fi

            local no_ext="${rel_path%.*}"

            # Convert root path to dot-separated target prefix
            local target_prefix="${root%/}"
            target_prefix="${target_prefix//\//.}"

            local target_name="$target_prefix.${no_ext//\//.}"

            targets="$targets$target_name"$'\n'
        done < <(find "$test_dir" -type f \( -name '*.cc' -o -name '*.py' -o -name '*.f90' -o -name '*.f' -o -name '*.c' \) -print0 2>/dev/null)

        # Add container targets for subdirectories
        while IFS= read -r -d '' subdir; do
            local rel_subdir="${subdir#$test_dir/}"
            [[ -z "$rel_subdir" ]] && continue

            local target_prefix="${root%/}"
            target_prefix="${target_prefix//\//.}"

            local subdir_target="$target_prefix.${rel_subdir//\//.}"
            targets="$targets$subdir_target"$'\n'
        done < <(find "$test_dir" -mindepth 1 -type d -print0 2>/dev/null)

        # Add the test suite root target itself
        local target_prefix="${root%/}"
        target_prefix="${target_prefix//\//.}"
        targets="${targets}$target_prefix"$'\n'

    done <<< "$suites"

    echo "$targets" | sort -u | grep -v '^$'
}

# =============================================================================
# Extern package discovery
# =============================================================================

# Scan the mm installation's make/extern/ directory to find available
# external packages and generate extern.{name}.info targets
# @return List of extern.{name}.info targets
_comp_cmd_mm__get_extern_targets()
{
    local mm_home
    mm_home=$(_comp_cmd_mm__find_mm_home)

    [[ -z "$mm_home" ]] && return

    local extern_dir="$mm_home/make/extern"
    [[ ! -d "$extern_dir" ]] && return

    for pkg_dir in "$extern_dir"/*/; do
        [[ ! -d "$pkg_dir" ]] && continue
        local pkg
        pkg=$(basename "$pkg_dir")
        echo "extern.$pkg.info"
    done
}

# =============================================================================
# Dynamic target variant info targets
# =============================================================================

# Scan make/targets/ for variant .mm files and generate targets.{variant}.info
# @return List of targets.{variant}.info targets
_comp_cmd_mm__get_variant_targets()
{
    local mm_home
    mm_home=$(_comp_cmd_mm__find_mm_home)

    [[ -z "$mm_home" ]] && return

    local targets_dir="$mm_home/make/targets"
    [[ ! -d "$targets_dir" ]] && return

    for variant_file in "$targets_dir"/*.mm; do
        [[ ! -f "$variant_file" ]] && continue
        local variant
        variant=$(basename "$variant_file" .mm)
        # Skip non-variant files (init, model, rules)
        case "$variant" in
            init|model|rules) continue ;;
        esac
        echo "targets.$variant.info"
    done
}

# =============================================================================
# Language info targets
# =============================================================================

# Scan make/languages/ for language .mm files and generate languages.{lang}.info
# @return List of languages.{lang}.info targets
_comp_cmd_mm__get_language_targets()
{
    local mm_home
    mm_home=$(_comp_cmd_mm__find_mm_home)

    [[ -z "$mm_home" ]] && return

    local lang_dir="$mm_home/make/languages"
    [[ ! -d "$lang_dir" ]] && return

    for lang_file in "$lang_dir"/*.mm; do
        [[ ! -f "$lang_file" ]] && continue
        local lang
        lang=$(basename "$lang_file" .mm)
        case "$lang" in
            init|model|rules) continue ;;
        esac
        echo "languages.$lang.info"
    done
}

# =============================================================================
# Generate all targets for completion
# =============================================================================

# Build the complete list of targets for the current project
# @return Space-separated list of all available targets
_comp_cmd_mm__get_all_targets()
{
    local targets=""

    # 1. Global targets (always available)
    targets="$_comp_cmd_mm__global_targets"

    # 2. Find project root
    local project_root
    project_root=$(_comp_cmd_mm__find_project_root)

    if [[ -n "$project_root" && -d "$project_root/.mm" ]]; then

        # 3. Per-project targets
        local project_names
        project_names=$(_comp_cmd_mm__get_project_names "$project_root")

        local proj
        for proj in $project_names; do
            # The bare project name is a target
            targets="$targets $proj"
            local suffix
            for suffix in $_comp_cmd_mm__project_suffixes; do
                targets="$targets ${proj}${suffix}"
            done
        done

        # 4. Parse asset declarations and generate suffixed targets
        local assets
        assets=$(_comp_cmd_mm__parse_assets "$project_root")

        if [[ -n "$assets" ]]; then
            while IFS='|' read -r asset_type asset_name; do
                [[ -z "$asset_type" || -z "$asset_name" ]] && continue

                # The bare asset name is always a target
                targets="$targets $asset_name"

                local suffix_list=""
                case "$asset_type" in
                    library)   suffix_list="$_comp_cmd_mm__library_suffixes" ;;
                    package)   suffix_list="$_comp_cmd_mm__package_suffixes" ;;
                    extension) suffix_list="$_comp_cmd_mm__extension_suffixes" ;;
                    testsuite) suffix_list="$_comp_cmd_mm__testsuite_suffixes" ;;
                    docker)    suffix_list="$_comp_cmd_mm__docker_suffixes" ;;
                    webpack)   suffix_list="$_comp_cmd_mm__webpack_suffixes" ;;
                    vite)      suffix_list="$_comp_cmd_mm__vite_suffixes" ;;
                    verbatim)  suffix_list="$_comp_cmd_mm__verbatim_suffixes" ;;
                esac

                local suffix
                for suffix in $suffix_list; do
                    targets="$targets ${asset_name}${suffix}"
                done
            done <<< "$assets"
        fi

        # 5. Dynamic test targets from filesystem scan
        local test_targets
        test_targets=$(_comp_cmd_mm__get_test_targets "$project_root")
        if [[ -n "$test_targets" ]]; then
            targets="$targets $(echo "$test_targets" | tr '\n' ' ')"
        fi
    fi

    # 6. External package info targets (from mm installation)
    local extern_targets
    extern_targets=$(_comp_cmd_mm__get_extern_targets)
    if [[ -n "$extern_targets" ]]; then
        targets="$targets $(echo "$extern_targets" | tr '\n' ' ')"
    fi

    # 7. Target variant info targets
    local variant_targets
    variant_targets=$(_comp_cmd_mm__get_variant_targets)
    if [[ -n "$variant_targets" ]]; then
        targets="$targets $(echo "$variant_targets" | tr '\n' ' ')"
    fi

    # 8. Language info targets
    local language_targets
    language_targets=$(_comp_cmd_mm__get_language_targets)
    if [[ -n "$language_targets" ]]; then
        targets="$targets $(echo "$language_targets" | tr '\n' ' ')"
    fi

    echo "$targets"
}

# =============================================================================
# Main completion function
# =============================================================================

_comp_cmd_mm()
{
    local cur prev words cword

    # Initialize completion - handle both old and new bash-completion APIs
    if declare -F _init_completion >/dev/null 2>&1; then
        _init_completion || return
    elif declare -F _get_comp_words_by_ref >/dev/null 2>&1; then
        _get_comp_words_by_ref cur prev words cword
    else
        # Fallback for systems without bash-completion library
        if [[ -n "${COMP_WORDS+x}" ]]; then
            cur="${COMP_WORDS[COMP_CWORD]}"
            prev="${COMP_WORDS[COMP_CWORD-1]:-}"
            cword=$COMP_CWORD
        else
            return 0
        fi
    fi

    # Handle options that take arguments (--option value format)
    case "$prev" in
        --prefix|--bldroot|--cfgdir|--engine|--portinfo)
            if declare -F _filedir >/dev/null 2>&1; then
                _filedir -d
            else
                COMPREPLY=($(compgen -d -- "$cur"))
            fi
            return
            ;;
        --local)
            if declare -F _filedir >/dev/null 2>&1; then
                _filedir '*.mm'
            else
                COMPREPLY=($(compgen -f -X '!*.mm' -- "$cur"))
            fi
            return
            ;;
        --target)
            local last_variant="${cur##*,}"
            local prefix="${cur%$last_variant}"

            # Valid variants from make/targets/*.mm (excluding init, model, rules)
            local variants="debug opt shared prof cov reldeb"
            local completions
            completions=$(compgen -W "$variants" -- "$last_variant")

            COMPREPLY=()
            for completion in $completions; do
                COMPREPLY+=("${prefix}${completion}")
            done
            return
            ;;
        --make)
            if declare -F _filedir >/dev/null 2>&1; then
                _filedir
            else
                COMPREPLY=($(compgen -c -- "$cur"))
            fi
            return
            ;;
        --pkgdb)
            COMPREPLY=($(compgen -W "adhoc conda macports dpkg" -- "$cur"))
            return
            ;;
        --slots|-j|--jobs)
            COMPREPLY=($(compgen -W "{1..32}" -- "$cur"))
            return
            ;;
        --palette)
            COMPREPLY=($(compgen -W "builtin ansi dumb" -- "$cur"))
            return
            ;;
        --compilers)
            COMPREPLY=($(compgen -W "gcc clang intel nvcc" -- "$cur"))
            return
            ;;
    esac

    # If current word starts with -, complete with mm options
    if [[ "$cur" == -* ]]; then
        # Handle --option=value format
        if [[ "$cur" == --*=* ]]; then
            local option="${cur%%=*}"
            local value="${cur#*=}"

            case "$option" in
                --target)
                    local last_variant="${value##*,}"
                    local prefix="${value%$last_variant}"

                    local variants="debug opt shared prof cov reldeb"
                    local completions
                    completions=$(compgen -W "$variants" -- "$last_variant")

                    COMPREPLY=()
                    for completion in $completions; do
                        COMPREPLY+=("${option}=${prefix}${completion}")
                    done
                    return
                    ;;
                --pkgdb)
                    COMPREPLY=($(compgen -W "adhoc conda macports dpkg" -- "$value" | sed "s/^/${option}=/"))
                    return
                    ;;
                --palette)
                    COMPREPLY=($(compgen -W "builtin ansi dumb" -- "$value" | sed "s/^/${option}=/"))
                    return
                    ;;
                --compilers)
                    COMPREPLY=($(compgen -W "gcc clang intel nvcc" -- "$value" | sed "s/^/${option}=/"))
                    return
                    ;;
                --prefix|--bldroot|--cfgdir|--engine|--portinfo)
                    if declare -F _filedir >/dev/null 2>&1; then
                        _filedir -d
                    else
                        COMPREPLY=($(compgen -d -- "$value" | sed "s|^|${option}=|"))
                    fi
                    return
                    ;;
            esac
        fi

        # Complete option names
        local opts="--help --version --prefix --bldroot --target --compilers
                    --local --pkgdb --setup --serial --slots --jobs
                    --show --dry --quiet --color --palette
                    --ignore --verbose --rules --trace --make
                    --cfgdir --engine --portinfo
                    -h -q -n -v -k -j"
        COMPREPLY=($(compgen -W "$opts" -- "$cur"))

        # Add = suffix for options that take values (no space after)
        if declare -F compopt >/dev/null 2>&1; then
            if [[ " --target --compilers --prefix --bldroot --pkgdb --palette " =~ " ${COMPREPLY[0]:-} " ]]; then
                compopt -o nospace
                COMPREPLY=("${COMPREPLY[0]}=")
            fi
        fi
        return
    fi

    # Otherwise, complete with make targets
    local all_targets
    all_targets=$(_comp_cmd_mm__get_all_targets)

    COMPREPLY=($(compgen -W "$all_targets" -- "$cur"))
}

# =============================================================================
# Registration and key bindings
# =============================================================================

# Register the completion function
complete -F _comp_cmd_mm mm

# Bind help key (default: F2, configurable via MM_HELP_KEY)
# Only bind when running interactively
if [[ $- == *i* ]]; then
    bind -x "\"${MM_HELP_KEY:-\eOQ}\":_comp_cmd_mm__show_target_help" 2>/dev/null
fi

# ex: filetype=sh
